# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' calculate partial AUC
#' @param time vector of time values
#' @param dv concentration measurements
#' @param range vector of min and max value of the partial auc range
auc_partial_cpp <- function(time, dv, range) {
    .Call('_mrgmisc_auc_partial_cpp', PACKAGE = 'mrgmisc', time, dv, range)
}

clean_nonmem <- function(x, sep, colname) {
    .Call('_mrgmisc_clean_nonmem', PACKAGE = 'mrgmisc', x, sep, colname)
}

clean_phi <- function(x, sep, colname) {
    .Call('_mrgmisc_clean_phi', PACKAGE = 'mrgmisc', x, sep, colname)
}

#' given NA values fill them with the next non-na value
#' @param x A numeric vector of values
#' @details
#' Works very well in context of dplyr to carry out backwards imputation
#' @examples 
#' fill_backward(c(1.0, NA, 2))
#' fill_backward(c(NA, 1, NA, 2))
#' library(dplyr)
#' df <- data_frame(id = c(1, 1, 2, 2), obs = c(1.2, 4.8, 2.5, NA))
#' df %>% group_by(id) %>% mutate(obs_imp = fill_backward(obs))
#' @export
fill_backward <- function(x) {
    .Call('_mrgmisc_fill_backward', PACKAGE = 'mrgmisc', x)
}

#' given NA values fill them with the final non-na value
#' @param x A numeric vector of values
#' @details
#' Works very well in context of dplyr to carry out last-observation-carried-foward
#' for different individuals. It will NOT replace leading NA's
#' @examples 
#' fill_forward(c(1.0, NA, 2))
#' fill_forward(c(NA, 1, NA, 2))
#' library(dplyr)
#' df <- data_frame(id = c(1, 1, 2, 2), obs = c(1.2, 4.8, 2.5, NA))
#' df %>% group_by(id) %>% mutate(obs_locf = fill_forward(obs))
#' @export
fill_forward <- function(x) {
    .Call('_mrgmisc_fill_forward', PACKAGE = 'mrgmisc', x)
}

#' Give the min value up to that point
#' @param x A numeric vector of values
#' @details
#' useful for safety analyses where an event may be defined as a certain change
#' in a biomarker. This will show you how the current measurement compares
#' to the minimum value up to that point
#' @examples 
#'min_through(c(4, 3, 3, 2, 4, 1))
#'[1] 4 3 3 2 2 1
#'
#'min_through(c(NA, 2))
#'[1] NA  2
#'
#' @export
min_through <- function(x) {
    .Call('_mrgmisc_min_through', PACKAGE = 'mrgmisc', x)
}

#' Give the max value up to that point
#' @param x A numeric vector of values
#' @details
#' useful for seeing how a current measurement compares to the maximum
#' value up to that point
#' @examples 
#'max_through(c(4, 3, 3, 2, 5, 1))
#'[1] 4 4 4 4 5 5
#'
#'max_through(c(NA, 2, 1, 4, 2))
#'[1] NA  2  2  4  4
#'
#' @export
max_through <- function(x) {
    .Call('_mrgmisc_max_through', PACKAGE = 'mrgmisc', x)
}

padLeft <- function(strings, numChars, paddingChar) {
    .Call('_mrgmisc_padLeft', PACKAGE = 'mrgmisc', strings, numChars, paddingChar)
}

replace_chars <- function(strings, values, replacement) {
    .Call('_mrgmisc_replace_chars', PACKAGE = 'mrgmisc', strings, values, replacement)
}

replace_spaces <- function(x) {
    .Call('_mrgmisc_replace_spaces', PACKAGE = 'mrgmisc', x)
}

#' given a set of bin ranges, assign each value to a bin
#' @details
#' Given a set of quantiles/bins/etc established from a separate dataset, it can 
#' be useful to assign the same bins to new or simulated data for comparisons
#' or to do additional analysis such as assign dropouts etc. This function can be
#' used to take the breakpoints to establish bins quickly and easily
#' @param x A numeric vector of values
#' @param left,right Boundary values
#' @export
set_bins_cpp <- function(x, left, right) {
    .Call('_mrgmisc_set_bins_cpp', PACKAGE = 'mrgmisc', x, left, right)
}

