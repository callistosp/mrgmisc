% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/chunking.R
\name{chunk}
\alias{chunk}
\alias{ids_per_plot}
\alias{chunk_grp}
\alias{chunk_list}
\alias{chunk_grp_list}
\title{Chunking}
\usage{
chunk(.x, .nchunk = parallel::detectCores())

ids_per_plot(id, id_per_plot = 9)

chunk_grp(.x, .nchunk = parallel::detectCores())

chunk_list(.x, .nchunk = parallel::detectCores())

chunk_grp_list(.x, .nchunk = parallel::detectCores())
}
\arguments{
\item{.x}{vector of values}

\item{.nchunk}{number of chunks to identify}

\item{id}{vector of ids (eg id column)}

\item{id_per_plot}{number of ids per plot. Default to 9}
}
\description{
Create chunks by group, unique values, and return as a vector or a list with elements.
}
\section{Functions}{
\itemize{
\item \code{ids_per_plot}: split IDs into groups to use for subsequent plotting
works very well with hadley wickham's purrr package to create a column
to split on then subsequently plot, see \code{vignette("Multiplot")} for details

\item \code{chunk_grp}: used when desirable to have unique elements in same chunk

\item \code{chunk_list}: used when desirable to have output be a list

\item \code{chunk_grp_list}: used when desirable to have output be a list with unique
elements in the same chunk
}}

\examples{
# Chunking will provide the chunk index by splitting the data 
# as evenly as possible into the number chunks specified

chunk(letters[1:9], 3) 

# When the vector length isn't divisible by the number of chunks, 
# some chunks will be filled with 1 more element than others. 

chunk(letters[c(1, 1, 2, 1:7)], 3)

# If interested in evenly chunking by unique values rather than balancing,
# notice how the first chunk contains many more elements since there are 3, 1's.

chunk_grp(c(1, 1, 1:7), 3)

# A potential next step after chunking is splitting the output into a list.

chunk_list(letters[1:9], 3)

# If we want to keep unique elements consistent as possible between chunks

chunk_grp_list(c(letters[1], letters[1], letters[1:7]), 3)

}
